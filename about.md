---
layout: chapter
title: About This Book
---

This is book is about the *how*, *why* and *what-if* of computing. Pick up a phone, a laptop, or any other kind of computer. We want to answer the following questions about this thing:

* How does it work?
* Why does it work that way?
* If things had gone differently, how it might have worked instead?
* What's going to change about these as technology evolves?

The insides of your computer tell a story, of people, computers, problems and solutions. If you tried to understand a computer by dividing it up into pieces, you'd end up with an absurd level of complexity and still be missing important context. The modern computer is best understood as a story of evolving designs, each step adding or changing something simple for a perfectly logical reason. In this book we will follow the trail of the steps that got us to where we are today. We'll see some of the paths not taken, and maybe even catch a glimpse of the path ahead.

This is a book for programmers, but we won't do much programming in this book. I hope to reshape the way you think about your 'platform' &mdash; the hardware and software that supports your code. You can get far without understanding how it works, but so long as you don't, you have no choice but to accept it for what it is. But if you learn it, you can change it. You replace it with something better. You can leave it be, but become a more conscientious consumer, writing simpler code that integrates more neatly runs faster.

If there's one thing frontend devs, backend devs, mobile devs, game devs, data scientists, AI and blockchain programming all have in common, it's this: they all need computers! Making better computers benefits them and is profitable for you. Plus, it's fun! Becoming an expert at building computers means understanding what exists and how we got here.

For me, this book is the "missing piece" of my college degree. In computer science, you deliberately abstract away as much as you can about the underlying computer, in the hope of making your findings as broadly applicable to as many computers as possible. In computer engineering, you focus narrowly on electronics and circuitry and thus miss out on the broader picture. The topics of this book are closer to the "systems" discipline of oddball topics that don't fit into either discipline, like operating systems, compilers, databases and networking. Computer science, engineering and systems are all pieces of the puzzle of how computers work, and my goal with this book is to weave them together into a whole.

Since the design of a computer is best understood evolutionally, this book is structured as a roughly historical walk of evolving designs. But this is not a history book; the goal is to show how one idea leads into the next, and sometimes provide context as to why some problems were tackled sooner than others. This is not meant to be a detailed accounting of every step that lead us to where we are today; this is better handled elsewhere.

Our journey begins at the critical point just *before* computers were machines . . .