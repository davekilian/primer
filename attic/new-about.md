---
layout: chapter
title: New pitch
---

This is book is about the *how*, *why* and *what-if* of computing. Pick up a phone, a laptop, or any other kind of computer. We want to answer the following questions about this thing:

* How does it work?
* Why does it work that way?
* If things had gone differently, how it might have worked instead?
* What's going to change about these as technology evolves?

The insides of your computer tell a story, of people, computers, problems and solutions. If you tried to understand a computer by dividing it up into pieces, you'd end up with an absurd level of complexity and still be missing important context. The modern computer is best understood as a story of evolving designs, each step adding or changing something simple for a perfectly logical reason. In this book we will follow the trail of the steps that got us to where we are today. We'll see some of the paths not taken, and maybe even catch a glimpse of the path ahead.

This is a book for programmers, but we won't do much programming in this book. I hope to reshape the way you think about your 'platform' &mdash; the hardware and software that supports your code. You can get far without understanding how it works, but so long as you don't, you have no choice but to accept it for what it is. But if you learn it, you can change it. You can evolve it, or replace it with something better. You can be a more conscientious consumer of the platform, writing simpler code that integrates more neatly runs faster.

If there's one thing frontend devs, backend devs, mobile devs, game devs, data scientists, AI and blockchain programming all have in common, it's this: they all need computers to do anything! Making a better computer is good for them, fun and profitable for you. Holding the long view and knowing how computers got to be the way they are today is key to figuring out what ought to be built next.

For me, this book is the "missing piece" of my college degree. In computer science, you deliberately abstract away everything we're about to talk about, in the hope of making your findings as broadly applicable as possible. In computer engineering, you focus narrowly on electronics and circuitry and thus miss the broader picture. The topics of this book are closer to the "systems" discipline of oddball topics that don't fit into either bucket, like operating systems, compilers, databases and networkings. Computer science, engineering and systems are all pieces of the puzzle of how computers work, and my goal with this book is to weave them together into a whole.

Since the design of a computer is best understood evolutionally, this book is structured as a roughly historical walk of evolving designs. But this is not a history book; the goal is to show how one idea leads into the next, and sometimes provide context as to why some problems were considered more important than others. This is not meant to be a detailed accounting of every step that lead us to where we are today; this is better handled elsewhere.

TODO then we need some way to lead into 
